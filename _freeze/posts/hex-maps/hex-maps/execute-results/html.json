{
  "hash": "648fbd7c693178142bfabffe80b0f185",
  "result": {
    "markdown": "---\ntitle: \"Hex maps for species occurrence data\"\ndescription: |\n  There are hundreds of color palettes in the R ecosystem, but sometimes we\n  might want to use colors from a specific image. Here I show how to \n  use the `paletter` package to create a color palette for the 2020 Eucalypt of \n  the Year: the Western Australian Gimlet.\nauthor: \n  - name: \"Matilda Stevenson\"\n  - name: \"Dax Kellie\"\n  - name: \"Martin Westgate\"\ndate: \"March 2021\"\ntoc: true\ntoc-location: left\ntoc-depth: 3\ncategories:\n  - Maps\n  - Eukaryota\n  - Animalia\n  - Chordata\n  - Aves\nfreeze: true\n---\n\n\n\n<!-- remove metadata section -->\n\n::: {.cell}\n<style type=\"text/css\">\n#title-block-header.quarto-title-block.default .quarto-title-meta {\n    display: none;\n}\n</style>\n:::\n\n\n\n<!-- Author card -->\n\n:::{.author-card}\n:::{.author-card-text}\n\n#### Author\nMatilda Stevenson  \n[Dax Kellie](https://labs.ala.org.au/people/Kellie_Dax/index.html)  \n[Martin Westgate](https://labs.ala.org.au/people/Westgate_Martin/index.html)  \n\n#### Date\nMarch 2021\n\n:::\n\n\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/matilda.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/martin.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n\n:::\n\n<!------------------------ Post starts here ------------------------>\n\nThe Atlas of Living Australia (ALA) holds records of magpie sightings from a number data providers like iNaturalist, eBird and BirdLife Australia. Let's make a visualisation of [Australian Bird of the Year 2018 winner](https://www.abc.net.au/news/2017-12-11/bird-of-the-year-magpie-defeats-teambinchicken/9245242), Magpies, using records held in the ALA.\n\n# Getting species occurrences\nAs with any R project, a good first step is to load the required packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# packages\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ozmaps)\nlibrary(sf)\nlibrary(hexbin)\n```\n:::\n\n\nWe will use the [{galah}](https://atlasoflivingaustralia.github.io/galah/index.html) package to download records.\n\nTo download species occurrence records, the {galah} package requires you to add an email registered with the ALA to `galah_config()`. If running this code yourself, you will need to add an email using the code below, substituting your email with `myemail@email.com`. This email address should be registered with the ALA, which you can do [here](https://auth.ala.org.au/userdetails/registration/createAccount)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(galah)\ngalah_config(email = \"myemail@email.com\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nNow we can download magpie occurrence records by using `atlas_occurrences()`. Note that we also set our data 'profile' to 'ALA'; this means we only download records that meet some basic data quality standards enforced by the atlas. This is optional, but tends to improve the quality of the data returned. \n(If you wish to see the data quality filters applied in the ALA profile, use `search_profile_attributes(\"ALA\")`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmagpie_occ <- galah_call() %>%\n  galah_identify(\"Cracticus tibicen\") %>%\n  galah_apply_profile(ALA) %>%\n  atlas_occurrences()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThis query will return 1,533,056 records\n```\n:::\n:::\n\n\nLet's have a look at the first few rows of the data we've just downloaded:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmagpie_occ %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  decimalL…¹ decim…² eventDate           scien…³ taxon…⁴ recor…⁵ dataR…⁶ occur…⁷\n       <dbl>   <dbl> <dttm>              <chr>   <chr>   <chr>   <chr>   <chr>  \n1      -45.0    169. 2019-09-04 14:00:00 Gymnor… https:… fd07f7… ALA sp… PRESENT\n2      -44.5    170. 2018-10-28 08:44:00 Gymnor… https:… 2f5933… Earth … PRESENT\n3      -44.1    170. 2019-05-02 15:18:00 Gymnor… https:… f09f13… Earth … PRESENT\n4      -43.6    147. 2019-03-10 13:00:00 Gymnor… https:… bf2044… eBird … PRESENT\n5      -43.6    147. 2018-02-05 13:00:00 Gymnor… https:… fe1644… eBird … PRESENT\n6      -43.6    147. 2018-02-05 13:00:00 Gymnor… https:… 52269e… eBird … PRESENT\n# … with abbreviated variable names ¹​decimalLatitude, ²​decimalLongitude,\n#   ³​scientificName, ⁴​taxonConceptID, ⁵​recordID, ⁶​dataResourceName,\n#   ⁷​occurrenceStatus\n```\n:::\n:::\n\n\n\nFor the purpose of this exercise, we're going to filter records not on the mainland or Tasmania.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_occ <- magpie_occ %>% filter(decimalLongitude < 155,\n                                      decimalLongitude > 110,\n                                      decimalLatitude > -45,\n                                      decimalLatitude < -10)\n```\n:::\n\n\n\n# Plotting binned data\n\nThe easiest way to create a hex map is using the `hexbin` package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(filtered_occ) +\n  geom_hex(mapping = aes(x = decimalLongitude, y = decimalLatitude), \n           bins = 47, \n           colour = \"white\") +\n  ylim(-45, -10) +\n  xlim(110, 155) +\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\")) +\n  coord_fixed() +\n  theme_bw() +\n  theme(\n    panel.border = element_blank(),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    axis.title = element_blank(),\n    legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](hex-maps_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nWhile automated methods are nice, it might sometimes be useful to create our hexagons manually. We can do this by manually creating hexagons, linking them to a grid of Australia, and adding our data of magpie counts to set the `fill` color of those hexagons. To achieve this, we first convert the map of Australia provided by `ozmaps` to the same coordinate system as ALA data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naus <- st_transform(ozmaps::ozmap_country, 4326)\n```\n:::\n\n\nWe then transform points from our data frame of magpie occurrences to the correct coordinates\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoints <- lapply(1:nrow(filtered_occ), function(x) {\n  st_point(c(as.numeric(filtered_occ[x,'decimalLongitude']),\n                        as.numeric(filtered_occ[x,'decimalLatitude'])))\n})\n```\n:::\n\n\nNow build the hexagonal grid\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_all <- st_make_grid(aus, \n                         cellsize = 1, \n                         what = \"polygons\", \n                         square = FALSE)[aus]\ngridSF <- st_as_sf(grid_all)\n\n# Find which polygon each point is in\nintersect <- st_intersects(st_as_sfc(points) %>% \n                             st_set_crs(4326), gridSF)\n\n# count the number of points in each hexagon\nfreqs <- as.data.frame(table(unlist(intersect)), \n                       stringsAsFactors = FALSE)\n\nnames(freqs) <- c(\"hex_id\", \"count\")\n```\n:::\n\n\nAdd our magpie counts data to the hexagons and fill hexagons without data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfreqs$hex_id <- as.integer(freqs$hex_id)\n\n# fill in the values for hexagons with no records\nfilled_freqs <- freqs %>%\n  complete(hex_id = full_seq(c(1,925), 1), \n           fill = list(count = 0))\ngridSF$n <- filled_freqs$count\n```\n:::\n\n\nFinally, build the plot\n\n\n::: {.cell .column-page layout-align=\"center\" preview='true'}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = gridSF, aes(fill = n), size = .01) +\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\"), \n                       na.value = \"white\", \n                       trans = \"log2\") +\n  ylim(-45, -10) +\n  xlim(110, 155) +\n  theme_bw() +\n  theme(\n    panel.border = element_blank(),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    axis.title = element_blank(),\n    legend.position = \"none\") \n```\n\n::: {.cell-output-display}\n![](hex-maps_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThat's it! All the extra work does make a difference in this case, providing a better representation of the spread of Mapgies across Australia. Manually constructing hex maps can be useful in other circumstances, too. For example, if we wanted to compare the number of magpies to contextual information within each polygon (such as rainfall or human population data), then manually constructing our own hexagons could help us to combine data from different sources.\n\nA final point is that we could have achieved the same result by creating polygons first, then querying the ALA for the number of magpie records in each polygon using `galah_geolocate()`. That's a bit more challenging, and not worthwhile in this case; but it can be an efficient solution where you require information on more species than there are polygons, for example. We'll come back to this point in a future blog post.",
    "supporting": [
      "hex-maps_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}